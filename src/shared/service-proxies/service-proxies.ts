/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.20.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';
import { BaseClient } from './BaseClient';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ServiceProxy extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://cms.okahyaoglu.net/api";
    }

    /**
     * Queries Project contents.
     * @param top (optional) Optional number of contents to take (Default: 20).
     * @param skip (optional) Optional number of contents to skip.
     * @param filter (optional) Optional OData filter.
     * @param search (optional) Optional OData full text search.
     * @param orderby (optional) Optional OData order definition.
     * @return Project content retrieved.
     */
    queryProjectContents(top: number | null | undefined, skip: number | null | undefined, filter: string | null | undefined, search: string | null | undefined, orderby: string | null | undefined): Observable<Anonymous> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project?";
        if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
        if (search !== undefined)
            url_ += "$search=" + encodeURIComponent("" + search) + "&";
        if (orderby !== undefined)
            url_ += "orderby=" + encodeURIComponent("" + orderby) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processQueryProjectContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryProjectContents(<any>response_);
                } catch (e) {
                    return <Observable<Anonymous>><any>_observableThrow(e);
                }
            } else
                return <Observable<Anonymous>><any>_observableThrow(response_);
        }));
    }

    protected processQueryProjectContents(response: HttpResponseBase): Observable<Anonymous> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Anonymous.fromJS(resultData200) : new Anonymous();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Anonymous>(<any>null);
    }

    /**
     * Create a Project content.
     * @param data The data of the content to be created or updated.

    Please note that each field is an object with one entry per language.
    If the field is not localizable you must use iv (Invariant Language) as a key.
    When you change the field to be localizable the value will become the value for the master language, depending what the master language is at this point of time.

    Read more about it at: https://docs.squidex.io/04-guides/02-api.html
     * @param publish (optional) Set to true to autopublish content.
     * @return Project content created.
     */
    createProjectContent(data: ProjectDto, publish: boolean | null | undefined): Observable<ProjectContentDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project?";
        if (publish !== undefined)
            url_ += "publish=" + encodeURIComponent("" + publish) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<ProjectContentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectContentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProjectContent(response: HttpResponseBase): Observable<ProjectContentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? ProjectContentDto.fromJS(resultData201) : new ProjectContentDto();
            return _observableOf(result201);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectContentDto>(<any>null);
    }

    /**
     * Get a Project content.
     * @param id The id of the Project content (GUID).
     * @return Project content found.
     */
    getProjectContent(id: string): Observable<ProjectContentDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<ProjectContentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectContentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectContent(response: HttpResponseBase): Observable<ProjectContentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectContentDto.fromJS(resultData200) : new ProjectContentDto();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectContentDto>(<any>null);
    }

    /**
     * Update a Project content.
     * @param data The data of the content to be created or updated.

    Please note that each field is an object with one entry per language.
    If the field is not localizable you must use iv (Invariant Language) as a key.
    When you change the field to be localizable the value will become the value for the master language, depending what the master language is at this point of time.

    Read more about it at: https://docs.squidex.io/04-guides/02-api.html
     * @param id The id of the Project content (GUID).
     * @return Project content updated.
     */
    updateProjectContent(data: ProjectDto, id: string): Observable<ProjectDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<ProjectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProjectContent(response: HttpResponseBase): Observable<ProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectDto.fromJS(resultData200) : new ProjectDto();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectDto>(<any>null);
    }

    /**
     * Patch a Project content.
     * @param data The data of the content to be created or updated.

    Please note that each field is an object with one entry per language.
    If the field is not localizable you must use iv (Invariant Language) as a key.
    When you change the field to be localizable the value will become the value for the master language, depending what the master language is at this point of time.

    Read more about it at: https://docs.squidex.io/04-guides/02-api.html
     * @param id The id of the Project content (GUID).
     * @return Project content patched.
     */
    pathProjectContent(data: ProjectDto, id: string): Observable<ProjectDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPathProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPathProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<ProjectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectDto>><any>_observableThrow(response_);
        }));
    }

    protected processPathProjectContent(response: HttpResponseBase): Observable<ProjectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectDto.fromJS(resultData200) : new ProjectDto();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectDto>(<any>null);
    }

    /**
     * Publish a Project content.
     * @param id The id of the Project content (GUID).
     * @return Project content published.
     */
    publishProjectContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPublishProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishProjectContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Unpublish a Project content.
     * @param id The id of the Project content (GUID).
     * @return Project content unpublished.
     */
    unpublishProjectContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}/unpublish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUnpublishProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpublishProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnpublishProjectContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Archive a Project content.
     * @param id The id of the Project content (GUID).
     * @return Project content restored.
     */
    archiveProjectContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}/archive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processArchiveProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchiveProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processArchiveProjectContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore a Project content.
     * @param id The id of the Project content (GUID).
     * @return Project content restored.
     */
    restoreProjectContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}/restore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreProjectContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Delete a Project content.
     * @param id The id of the Project content (GUID).
     * @return Project content deleted.
     */
    deleteProjectContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/project/{id}/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteProjectContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProjectContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProjectContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Queries Workexperience contents.
     * @param top (optional) Optional number of contents to take (Default: 20).
     * @param skip (optional) Optional number of contents to skip.
     * @param filter (optional) Optional OData filter.
     * @param search (optional) Optional OData full text search.
     * @param orderby (optional) Optional OData order definition.
     * @return Workexperience content retrieved.
     */
    queryWorkexperienceContents(top: number | null | undefined, skip: number | null | undefined, filter: string | null | undefined, search: string | null | undefined, orderby: string | null | undefined): Observable<Anonymous2> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience?";
        if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (filter !== undefined)
            url_ += "$filter=" + encodeURIComponent("" + filter) + "&";
        if (search !== undefined)
            url_ += "$search=" + encodeURIComponent("" + search) + "&";
        if (orderby !== undefined)
            url_ += "orderby=" + encodeURIComponent("" + orderby) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processQueryWorkexperienceContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryWorkexperienceContents(<any>response_);
                } catch (e) {
                    return <Observable<Anonymous2>><any>_observableThrow(e);
                }
            } else
                return <Observable<Anonymous2>><any>_observableThrow(response_);
        }));
    }

    protected processQueryWorkexperienceContents(response: HttpResponseBase): Observable<Anonymous2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Anonymous2.fromJS(resultData200) : new Anonymous2();
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Anonymous2>(<any>null);
    }

    /**
     * Create a Workexperience content.
     * @param data The data of the content to be created or updated.

    Please note that each field is an object with one entry per language.
    If the field is not localizable you must use iv (Invariant Language) as a key.
    When you change the field to be localizable the value will become the value for the master language, depending what the master language is at this point of time.

    Read more about it at: https://docs.squidex.io/04-guides/02-api.html
     * @param publish (optional) Set to true to autopublish content.
     * @return Workexperience content created.
     */
    createWorkexperienceContent(data: WorkexperienceDto, publish: boolean | null | undefined): Observable<WorkexperienceContentDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience?";
        if (publish !== undefined)
            url_ += "publish=" + encodeURIComponent("" + publish) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<WorkexperienceContentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkexperienceContentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWorkexperienceContent(response: HttpResponseBase): Observable<WorkexperienceContentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? WorkexperienceContentDto.fromJS(resultData201) : new WorkexperienceContentDto();
            return _observableOf(result201);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkexperienceContentDto>(<any>null);
    }

    /**
     * Get a Workexperience content.
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content found.
     */
    getWorkexperienceContent(id: string): Observable<WorkexperienceContentDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processGetWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<WorkexperienceContentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkexperienceContentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkexperienceContent(response: HttpResponseBase): Observable<WorkexperienceContentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkexperienceContentDto.fromJS(resultData200) : new WorkexperienceContentDto();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkexperienceContentDto>(<any>null);
    }

    /**
     * Update a Workexperience content.
     * @param data The data of the content to be created or updated.

    Please note that each field is an object with one entry per language.
    If the field is not localizable you must use iv (Invariant Language) as a key.
    When you change the field to be localizable the value will become the value for the master language, depending what the master language is at this point of time.

    Read more about it at: https://docs.squidex.io/04-guides/02-api.html
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content updated.
     */
    updateWorkexperienceContent(data: WorkexperienceDto, id: string): Observable<WorkexperienceDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<WorkexperienceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkexperienceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWorkexperienceContent(response: HttpResponseBase): Observable<WorkexperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkexperienceDto.fromJS(resultData200) : new WorkexperienceDto();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkexperienceDto>(<any>null);
    }

    /**
     * Patch a Workexperience content.
     * @param data The data of the content to be created or updated.

    Please note that each field is an object with one entry per language.
    If the field is not localizable you must use iv (Invariant Language) as a key.
    When you change the field to be localizable the value will become the value for the master language, depending what the master language is at this point of time.

    Read more about it at: https://docs.squidex.io/04-guides/02-api.html
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content patched.
     */
    pathWorkexperienceContent(data: WorkexperienceDto, id: string): Observable<WorkexperienceDto> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("patch", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPathWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPathWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<WorkexperienceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkexperienceDto>><any>_observableThrow(response_);
        }));
    }

    protected processPathWorkexperienceContent(response: HttpResponseBase): Observable<WorkexperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkexperienceDto.fromJS(resultData200) : new WorkexperienceDto();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkexperienceDto>(<any>null);
    }

    /**
     * Publish a Workexperience content.
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content published.
     */
    publishWorkexperienceContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processPublishWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishWorkexperienceContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Unpublish a Workexperience content.
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content unpublished.
     */
    unpublishWorkexperienceContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}/unpublish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processUnpublishWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpublishWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnpublishWorkexperienceContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Archive a Workexperience content.
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content restored.
     */
    archiveWorkexperienceContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}/archive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processArchiveWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchiveWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processArchiveWorkexperienceContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Restore a Workexperience content.
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content restored.
     */
    restoreWorkexperienceContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}/restore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreWorkexperienceContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Delete a Workexperience content.
     * @param id The id of the Workexperience content (GUID).
     * @return Workexperience content deleted.
     */
    deleteWorkexperienceContent(id: string): Observable<void> {
        let url_ = this.baseUrl + "/content/okahyaoglunet/workexperience/{id}/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteWorkexperienceContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkexperienceContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWorkexperienceContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : new ErrorDto();
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class ProjectTitleProperty implements IProjectTitleProperty {
    /** English */
    en!: string | undefined;
    /** Turkish */
    tr!: string | undefined;

    constructor(data?: IProjectTitleProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.en = data["en"];
            this.tr = data["tr"];
        }
    }

    static fromJS(data: any): ProjectTitleProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTitleProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["tr"] = this.tr;
        return data;
    }
}

export interface IProjectTitleProperty {
    /** English */
    en: string | undefined;
    /** Turkish */
    tr: string | undefined;
}

export class ProjectSubtitleProperty implements IProjectSubtitleProperty {
    /** English */
    en!: string | undefined;
    /** Turkish */
    tr!: string | undefined;

    constructor(data?: IProjectSubtitleProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.en = data["en"];
            this.tr = data["tr"];
        }
    }

    static fromJS(data: any): ProjectSubtitleProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSubtitleProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["tr"] = this.tr;
        return data;
    }
}

export interface IProjectSubtitleProperty {
    /** English */
    en: string | undefined;
    /** Turkish */
    tr: string | undefined;
}

export class ProjectDescriptionProperty implements IProjectDescriptionProperty {
    /** English */
    en!: string | undefined;
    /** Turkish */
    tr!: string | undefined;

    constructor(data?: IProjectDescriptionProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.en = data["en"];
            this.tr = data["tr"];
        }
    }

    static fromJS(data: any): ProjectDescriptionProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDescriptionProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["tr"] = this.tr;
        return data;
    }
}

export interface IProjectDescriptionProperty {
    /** English */
    en: string | undefined;
    /** Turkish */
    tr: string | undefined;
}

export class ProjectOrderProperty implements IProjectOrderProperty {
    /** Invariant */
    iv!: number;

    constructor(data?: IProjectOrderProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iv = data["iv"];
        }
    }

    static fromJS(data: any): ProjectOrderProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectOrderProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iv"] = this.iv;
        return data;
    }
}

export interface IProjectOrderProperty {
    /** Invariant */
    iv: number;
}

export class ProjectLinkProperty implements IProjectLinkProperty {
    /** Invariant */
    iv!: string | undefined;

    constructor(data?: IProjectLinkProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iv = data["iv"];
        }
    }

    static fromJS(data: any): ProjectLinkProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLinkProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iv"] = this.iv;
        return data;
    }
}

export interface IProjectLinkProperty {
    /** Invariant */
    iv: string | undefined;
}

export class ProjectImageFolderNameProperty implements IProjectImageFolderNameProperty {
    /** Invariant */
    iv!: string | undefined;

    constructor(data?: IProjectImageFolderNameProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iv = data["iv"];
        }
    }

    static fromJS(data: any): ProjectImageFolderNameProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectImageFolderNameProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iv"] = this.iv;
        return data;
    }
}

export interface IProjectImageFolderNameProperty {
    /** Invariant */
    iv: string | undefined;
}

export class ProjectImagesProperty implements IProjectImagesProperty {
    /** Invariant */
    iv!: string[] | undefined;

    constructor(data?: IProjectImagesProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["iv"] && data["iv"].constructor === Array) {
                this.iv = [] as any;
                for (let item of data["iv"])
                    this.iv!.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectImagesProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectImagesProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.iv && this.iv.constructor === Array) {
            data["iv"] = [];
            for (let item of this.iv)
                data["iv"].push(item);
        }
        return data;
    }
}

export interface IProjectImagesProperty {
    /** Invariant */
    iv: string[] | undefined;
}

export class ProjectThumbsProperty implements IProjectThumbsProperty {
    /** Invariant */
    iv!: string[] | undefined;

    constructor(data?: IProjectThumbsProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["iv"] && data["iv"].constructor === Array) {
                this.iv = [] as any;
                for (let item of data["iv"])
                    this.iv!.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectThumbsProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectThumbsProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.iv && this.iv.constructor === Array) {
            data["iv"] = [];
            for (let item of this.iv)
                data["iv"].push(item);
        }
        return data;
    }
}

export interface IProjectThumbsProperty {
    /** Invariant */
    iv: string[] | undefined;
}

export class ProjectDto implements IProjectDto {
    /** Title */
    title!: ProjectTitleProperty | undefined;
    /** Subtitle */
    subtitle!: ProjectSubtitleProperty | undefined;
    /** Description */
    description!: ProjectDescriptionProperty | undefined;
    /** Order */
    order!: ProjectOrderProperty;
    /** Link */
    link!: ProjectLinkProperty | undefined;
    /** ImageFolderName */
    imageFolderName!: ProjectImageFolderNameProperty | undefined;
    /** Images */
    images!: ProjectImagesProperty | undefined;
    /** Thumbs */
    thumbs!: ProjectThumbsProperty | undefined;

    constructor(data?: IProjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.order = new ProjectOrderProperty();
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["Title"] ? ProjectTitleProperty.fromJS(data["Title"]) : <any>undefined;
            this.subtitle = data["Subtitle"] ? ProjectSubtitleProperty.fromJS(data["Subtitle"]) : <any>undefined;
            this.description = data["Description"] ? ProjectDescriptionProperty.fromJS(data["Description"]) : <any>undefined;
            this.order = data["Order"] ? ProjectOrderProperty.fromJS(data["Order"]) : new ProjectOrderProperty();
            this.link = data["Link"] ? ProjectLinkProperty.fromJS(data["Link"]) : <any>undefined;
            this.imageFolderName = data["ImageFolderName"] ? ProjectImageFolderNameProperty.fromJS(data["ImageFolderName"]) : <any>undefined;
            this.images = data["Images"] ? ProjectImagesProperty.fromJS(data["Images"]) : <any>undefined;
            this.thumbs = data["Thumbs"] ? ProjectThumbsProperty.fromJS(data["Thumbs"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title ? this.title.toJSON() : <any>undefined;
        data["Subtitle"] = this.subtitle ? this.subtitle.toJSON() : <any>undefined;
        data["Description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["Order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["Link"] = this.link ? this.link.toJSON() : <any>undefined;
        data["ImageFolderName"] = this.imageFolderName ? this.imageFolderName.toJSON() : <any>undefined;
        data["Images"] = this.images ? this.images.toJSON() : <any>undefined;
        data["Thumbs"] = this.thumbs ? this.thumbs.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectDto {
    /** Title */
    title: ProjectTitleProperty | undefined;
    /** Subtitle */
    subtitle: ProjectSubtitleProperty | undefined;
    /** Description */
    description: ProjectDescriptionProperty | undefined;
    /** Order */
    order: ProjectOrderProperty;
    /** Link */
    link: ProjectLinkProperty | undefined;
    /** ImageFolderName */
    imageFolderName: ProjectImageFolderNameProperty | undefined;
    /** Images */
    images: ProjectImagesProperty | undefined;
    /** Thumbs */
    thumbs: ProjectThumbsProperty | undefined;
}

export class ProjectContentDto implements IProjectContentDto {
    /** The id of the project content. */
    id!: string;
    /** The data of the project. */
    data!: ProjectDto;
    /** The version of the project. */
    version!: number;
    /** The date and time when the project content has been created. */
    created!: moment.Moment;
    /** The user that has created the project content. */
    createdBy!: string;
    /** The date and time when the project content has been modified last. */
    lastModified!: moment.Moment;
    /** OrderNo of the content item for project. */
    orderNo!: number;
    /** The user that has updated the project content last. */
    lastModifiedBy!: string;

    constructor(data?: IProjectContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new ProjectDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.data = data["data"] ? ProjectDto.fromJS(data["data"]) : new ProjectDto();
            this.version = data["version"];
            this.created = data["created"] ? moment.parseZone(data["created"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.lastModified = data["lastModified"] ? moment.parseZone(data["lastModified"].toString()) : <any>undefined;
            this.orderNo = data["orderNo"];
            this.lastModifiedBy = data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): ProjectContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString(true) : <any>undefined;
        data["orderNo"] = this.orderNo;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IProjectContentDto {
    /** The id of the project content. */
    id: string;
    /** The data of the project. */
    data: ProjectDto;
    /** The version of the project. */
    version: number;
    /** The date and time when the project content has been created. */
    created: moment.Moment;
    /** The user that has created the project content. */
    createdBy: string;
    /** The date and time when the project content has been modified last. */
    lastModified: moment.Moment;
    /** OrderNo of the content item for project. */
    orderNo: number;
    /** The user that has updated the project content last. */
    lastModifiedBy: string;
}

export class WorkexperiencePlaceProperty implements IWorkexperiencePlaceProperty {
    /** English */
    en!: string | undefined;
    /** Turkish */
    tr!: string | undefined;

    constructor(data?: IWorkexperiencePlaceProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.en = data["en"];
            this.tr = data["tr"];
        }
    }

    static fromJS(data: any): WorkexperiencePlaceProperty {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperiencePlaceProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["tr"] = this.tr;
        return data;
    }
}

export interface IWorkexperiencePlaceProperty {
    /** English */
    en: string | undefined;
    /** Turkish */
    tr: string | undefined;
}

export class WorkexperiencePositionProperty implements IWorkexperiencePositionProperty {
    /** Invariant */
    iv!: string | undefined;

    constructor(data?: IWorkexperiencePositionProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iv = data["iv"];
        }
    }

    static fromJS(data: any): WorkexperiencePositionProperty {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperiencePositionProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iv"] = this.iv;
        return data;
    }
}

export interface IWorkexperiencePositionProperty {
    /** Invariant */
    iv: string | undefined;
}

export class WorkexperienceDateRangeProperty implements IWorkexperienceDateRangeProperty {
    /** English */
    en!: string | undefined;
    /** Turkish */
    tr!: string | undefined;

    constructor(data?: IWorkexperienceDateRangeProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.en = data["en"];
            this.tr = data["tr"];
        }
    }

    static fromJS(data: any): WorkexperienceDateRangeProperty {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperienceDateRangeProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["tr"] = this.tr;
        return data;
    }
}

export interface IWorkexperienceDateRangeProperty {
    /** English */
    en: string | undefined;
    /** Turkish */
    tr: string | undefined;
}

export class WorkexperienceDescriptionProperty implements IWorkexperienceDescriptionProperty {
    /** English */
    en!: string | undefined;
    /** Turkish */
    tr!: string | undefined;

    constructor(data?: IWorkexperienceDescriptionProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.en = data["en"];
            this.tr = data["tr"];
        }
    }

    static fromJS(data: any): WorkexperienceDescriptionProperty {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperienceDescriptionProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["tr"] = this.tr;
        return data;
    }
}

export interface IWorkexperienceDescriptionProperty {
    /** English */
    en: string | undefined;
    /** Turkish */
    tr: string | undefined;
}

export class WorkexperienceSortProperty implements IWorkexperienceSortProperty {
    /** Invariant */
    iv!: number;

    constructor(data?: IWorkexperienceSortProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.iv = data["iv"];
        }
    }

    static fromJS(data: any): WorkexperienceSortProperty {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperienceSortProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iv"] = this.iv;
        return data;
    }
}

export interface IWorkexperienceSortProperty {
    /** Invariant */
    iv: number;
}

export class WorkexperienceDto implements IWorkexperienceDto {
    /** Place */
    place!: WorkexperiencePlaceProperty | undefined;
    /** Position */
    position!: WorkexperiencePositionProperty | undefined;
    /** DateRange */
    dateRange!: WorkexperienceDateRangeProperty | undefined;
    /** Description */
    description!: WorkexperienceDescriptionProperty | undefined;
    /** Sort */
    sort!: WorkexperienceSortProperty;

    constructor(data?: IWorkexperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sort = new WorkexperienceSortProperty();
        }
    }

    init(data?: any) {
        if (data) {
            this.place = data["Place"] ? WorkexperiencePlaceProperty.fromJS(data["Place"]) : <any>undefined;
            this.position = data["Position"] ? WorkexperiencePositionProperty.fromJS(data["Position"]) : <any>undefined;
            this.dateRange = data["DateRange"] ? WorkexperienceDateRangeProperty.fromJS(data["DateRange"]) : <any>undefined;
            this.description = data["Description"] ? WorkexperienceDescriptionProperty.fromJS(data["Description"]) : <any>undefined;
            this.sort = data["Sort"] ? WorkexperienceSortProperty.fromJS(data["Sort"]) : new WorkexperienceSortProperty();
        }
    }

    static fromJS(data: any): WorkexperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["Position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["DateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
        data["Description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["Sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkexperienceDto {
    /** Place */
    place: WorkexperiencePlaceProperty | undefined;
    /** Position */
    position: WorkexperiencePositionProperty | undefined;
    /** DateRange */
    dateRange: WorkexperienceDateRangeProperty | undefined;
    /** Description */
    description: WorkexperienceDescriptionProperty | undefined;
    /** Sort */
    sort: WorkexperienceSortProperty;
}

export class WorkexperienceContentDto implements IWorkexperienceContentDto {
    /** The id of the workexperience content. */
    id!: string;
    /** The data of the workexperience. */
    data!: WorkexperienceDto;
    /** The version of the workexperience. */
    version!: number;
    /** The date and time when the workexperience content has been created. */
    created!: moment.Moment;
    /** The user that has created the workexperience content. */
    createdBy!: string;
    /** The date and time when the workexperience content has been modified last. */
    lastModified!: moment.Moment;
    /** OrderNo of the content item for workexperience. */
    orderNo!: number;
    /** The user that has updated the workexperience content last. */
    lastModifiedBy!: string;

    constructor(data?: IWorkexperienceContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new WorkexperienceDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.data = data["data"] ? WorkexperienceDto.fromJS(data["data"]) : new WorkexperienceDto();
            this.version = data["version"];
            this.created = data["created"] ? moment.parseZone(data["created"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.lastModified = data["lastModified"] ? moment.parseZone(data["lastModified"].toString()) : <any>undefined;
            this.orderNo = data["orderNo"];
            this.lastModifiedBy = data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): WorkexperienceContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkexperienceContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString(true) : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString(true) : <any>undefined;
        data["orderNo"] = this.orderNo;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IWorkexperienceContentDto {
    /** The id of the workexperience content. */
    id: string;
    /** The data of the workexperience. */
    data: WorkexperienceDto;
    /** The version of the workexperience. */
    version: number;
    /** The date and time when the workexperience content has been created. */
    created: moment.Moment;
    /** The user that has created the workexperience content. */
    createdBy: string;
    /** The date and time when the workexperience content has been modified last. */
    lastModified: moment.Moment;
    /** OrderNo of the content item for workexperience. */
    orderNo: number;
    /** The user that has updated the workexperience content last. */
    lastModifiedBy: string;
}

export class ErrorDto implements IErrorDto {
    /** Error message. */
    message!: string;
    /** Detailed error messages. */
    details!: string[] | undefined;
    /** Status code of the http response. */
    statusCode!: number | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["Message"];
            if (data["Details"] && data["Details"].constructor === Array) {
                this.details = [] as any;
                for (let item of data["Details"])
                    this.details!.push(item);
            }
            this.statusCode = data["StatusCode"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        if (this.details && this.details.constructor === Array) {
            data["Details"] = [];
            for (let item of this.details)
                data["Details"].push(item);
        }
        data["StatusCode"] = this.statusCode;
        return data;
    }
}

export interface IErrorDto {
    /** Error message. */
    message: string;
    /** Detailed error messages. */
    details: string[] | undefined;
    /** Status code of the http response. */
    statusCode: number | undefined;
}

export class Anonymous implements IAnonymous {
    /** The total number of Project contents. */
    total!: number;
    /** The Project contents. */
    items!: ProjectContentDto[];

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ProjectContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAnonymous {
    /** The total number of Project contents. */
    total: number;
    /** The Project contents. */
    items: ProjectContentDto[];
}

export class Anonymous2 implements IAnonymous2 {
    /** The total number of Workexperience contents. */
    total!: number;
    /** The Workexperience contents. */
    items!: WorkexperienceContentDto[];

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkexperienceContentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAnonymous2 {
    /** The total number of Workexperience contents. */
    total: number;
    /** The Workexperience contents. */
    items: WorkexperienceContentDto[];
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
